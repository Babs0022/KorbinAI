
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // User Settings
    match /userSettings/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // User Prompt History
    match /users/{userId}/promptHistory/{promptId} {
      allow read, write, delete: if request.auth != null && request.auth.uid == userId;
    }

    // Referral Codes
    match /referralCodes/{codeId} {
      // For signup: Unauthenticated users can query for a specific code.
      // This relies on the client query being `where("code", "==", enteredCode).limit(1)`.
      // WARNING: This potentially allows listing all codes if the client query is not specific enough
      // or if not properly indexed. Consider a callable function for production-grade code validation.
      allow list: if request.auth == null;
      allow get: if request.auth == null; // If somehow an ID is known by unauth user.

      // For authenticated users:
      // Can get their own code directly if ID is known.
      allow get: if request.auth.uid != null && request.auth.uid == resource.data.userId;
      // Can list codes. Client query *must* filter `where("userId", "==", request.auth.uid)`.
      // The 'get' rule above protects individual document contents if the list query is too broad.
      allow list: if request.auth.uid != null;

      // Creating a new referral code (by the owner)
      allow create: if request.auth.uid != null &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.isActive == true &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.keys().hasAll(['code', 'userId', 'isActive', 'usesLeft', 'createdAt', 'usersReferred']) &&
                       request.resource.data.code is string &&
                       request.resource.data.userId is string &&
                       request.resource.data.isActive is bool &&
                       request.resource.data.usesLeft is number &&
                       request.resource.data.usersReferred is list &&
                       request.resource.data.usersReferred.size() == 0;

      // Updating a referral code (e.g., when a new user signs up with it)
      allow update: if request.auth.uid != null &&
                       (
                         // Scenario 1: New user used this code during signup
                         // Check if the updater is being added to usersReferred (or already there, though ideally only once)
                         // and usesLeft is being decremented, and lastUsedAt is being set.
                         (request.resource.data.usersReferred.hasAny([request.auth.uid]) &&
                          request.resource.data.usesLeft == resource.data.usesLeft - 1 &&
                          request.resource.data.lastUsedAt == request.time &&
                          // Ensure only allowed fields are changing: usesLeft, usersReferred, lastUsedAt
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['usesLeft', 'usersReferred', 'lastUsedAt']) &&
                          // Ensure other core fields are not changed by this update operation
                          request.resource.data.code == resource.data.code &&
                          request.resource.data.userId == resource.data.userId &&
                          request.resource.data.isActive == resource.data.isActive &&
                          request.resource.data.createdAt == resource.data.createdAt)
                         // Add other update scenarios here if needed, e.g., owner deactivating their code.
                       );
    }

    // Users Collection (stores basic user info, including who referred them)
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      // Allow creation during signup
      allow create: if request.auth != null && request.auth.uid == userId &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.createdAt == request.time;
      // Allow updates by owner (e.g. to display name if not syncing with Auth profile)
      allow update: if request.auth != null && request.auth.uid == userId;
    }

    // Transactions Collection
    match /transactions/{transactionId} {
      // User can read their own transactions
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      // Function creates transactions initially
      allow create: if get(/databases/$(database)/documents/functionsExecutionToken/$(request.auth.uid)).data.token != null; // Example for function-only write
      // Function updates transaction status
      allow update: if get(/databases/$(database)/documents/functionsExecutionToken/$(request.auth.uid)).data.token != null; // Example for function-only write
      // Or, more simply for now if functions are trusted:
      // allow read, write: if true; // (Assuming functions handle security - NOT recommended for prod)
    }

    // User Subscriptions Collection
    match /userSubscriptions/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      // Only backend functions should write to subscriptions
      allow write: if get(/databases/$(database)/documents/functionsExecutionToken/$(request.auth.uid)).data.token != null; // Example
    }

  }
}
